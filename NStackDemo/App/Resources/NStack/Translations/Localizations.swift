// ----------------------------------------------------------------------
// File generated by NStack Translations Generator v5.0.
//
// Copyright (c) 2019 Nodes ApS
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------

import Foundation
import NStackSDK

#if canImport(NLocalizationManager)
import NLocalizationManager
#endif

#if canImport(LocalizationManager)
import LocalizationManager
#endif

public var lo: Localizations {
    guard let manager = NStack.sharedInstance.localizationManager else {
        return Localizations()
    }
    return try! manager.localization()
}

public var tr: Localizations { lo }

public final class Localizations: LocalizableModel {
    public var defaultSection = DefaultSection()
    public var error = Error()

    enum CodingKeys: String, CodingKey {
        case defaultSection = "default"
        case error
    }

    public override init() { super.init() }

    public required init(from decoder: Decoder) throws {
        super.init()
        let container = try decoder.container(keyedBy: CodingKeys.self)
        defaultSection = try container.decodeIfPresent(DefaultSection.self, forKey: .defaultSection) ?? defaultSection
        error = try container.decodeIfPresent(Error.self, forKey: .error) ?? error
    }

    public override subscript(key: String) -> LocalizableSection? {
        switch key {
        case CodingKeys.defaultSection.stringValue: return defaultSection
        case CodingKeys.error.stringValue: return error
        default: return nil
        }
    }

    public final class DefaultSection: LocalizableSection {
        public var ok = ""
        public var save = ""
        public var cancel = ""
        public var yes = ""
        public var skip = ""
        public var previous = ""
        public var back = ""
        public var next = ""
        public var retry = ""
        public var later = ""
        public var no = ""
        public var edit = ""
        public var settings = ""

        enum CodingKeys: String, CodingKey {
            case ok
            case save
            case cancel
            case yes
            case skip
            case previous
            case back
            case next
            case retry
            case later
            case no
            case edit
            case settings
        }

        public override init() { super.init() }

        public required init(from decoder: Decoder) throws {
            super.init()
            let container = try decoder.container(keyedBy: CodingKeys.self)
            ok = try container.decodeIfPresent(String.self, forKey: .ok) ?? "__ok"
            save = try container.decodeIfPresent(String.self, forKey: .save) ?? "__save"
            cancel = try container.decodeIfPresent(String.self, forKey: .cancel) ?? "__cancel"
            yes = try container.decodeIfPresent(String.self, forKey: .yes) ?? "__yes"
            skip = try container.decodeIfPresent(String.self, forKey: .skip) ?? "__skip"
            previous = try container.decodeIfPresent(String.self, forKey: .previous) ?? "__previous"
            back = try container.decodeIfPresent(String.self, forKey: .back) ?? "__back"
            next = try container.decodeIfPresent(String.self, forKey: .next) ?? "__next"
            retry = try container.decodeIfPresent(String.self, forKey: .retry) ?? "__retry"
            later = try container.decodeIfPresent(String.self, forKey: .later) ?? "__later"
            no = try container.decodeIfPresent(String.self, forKey: .no) ?? "__no"
            edit = try container.decodeIfPresent(String.self, forKey: .edit) ?? "__edit"
            settings = try container.decodeIfPresent(String.self, forKey: .settings) ?? "__settings"
        }

        public override subscript(key: String) -> String? {
            switch key {
            case CodingKeys.ok.stringValue: return ok
            case CodingKeys.save.stringValue: return save
            case CodingKeys.cancel.stringValue: return cancel
            case CodingKeys.yes.stringValue: return yes
            case CodingKeys.skip.stringValue: return skip
            case CodingKeys.previous.stringValue: return previous
            case CodingKeys.back.stringValue: return back
            case CodingKeys.next.stringValue: return next
            case CodingKeys.retry.stringValue: return retry
            case CodingKeys.later.stringValue: return later
            case CodingKeys.no.stringValue: return no
            case CodingKeys.edit.stringValue: return edit
            case CodingKeys.settings.stringValue: return settings
            default: return nil
            }
        }
    }

    public final class Error: LocalizableSection {
        public var connectionError = ""
        public var authenticationError = ""
        public var unknownError = ""
        public var errorTitle = ""

        enum CodingKeys: String, CodingKey {
            case connectionError
            case authenticationError
            case unknownError
            case errorTitle
        }

        public override init() { super.init() }

        public required init(from decoder: Decoder) throws {
            super.init()
            let container = try decoder.container(keyedBy: CodingKeys.self)
            connectionError = try container.decodeIfPresent(String.self, forKey: .connectionError) ?? "__connectionError"
            authenticationError = try container.decodeIfPresent(String.self, forKey: .authenticationError) ?? "__authenticationError"
            unknownError = try container.decodeIfPresent(String.self, forKey: .unknownError) ?? "__unknownError"
            errorTitle = try container.decodeIfPresent(String.self, forKey: .errorTitle) ?? "__errorTitle"
        }

        public override subscript(key: String) -> String? {
            switch key {
            case CodingKeys.connectionError.stringValue: return connectionError
            case CodingKeys.authenticationError.stringValue: return authenticationError
            case CodingKeys.unknownError.stringValue: return unknownError
            case CodingKeys.errorTitle.stringValue: return errorTitle
            default: return nil
            }
        }
    }
}

