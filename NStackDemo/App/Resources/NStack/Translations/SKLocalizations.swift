// ----------------------------------------------------------------------
// File generated by NStack Translations Generator v5.0.
//
// Copyright (c) 2019 Nodes ApS
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------

import Foundation
import NStackSDK

#if canImport(NLocalizationManager)
import NLocalizationManager
#endif

#if canImport(LocalizationManager)
import LocalizationManager
#endif

public var skl: SKLocalizations {
    return SKLocalizations()
}

public var skt: SKLocalizations { skl }

public final class SKLocalizations: LocalizableModel {
    public var error = Error()
    public var defaultSection = DefaultSection()

    enum CodingKeys: String, CodingKey {
        case error
        case defaultSection = "default"
    }

    public override init() { super.init() }

    public required init(from decoder: Decoder) throws {
        super.init()
        let container = try decoder.container(keyedBy: CodingKeys.self)
        error = try container.decodeIfPresent(Error.self, forKey: .error) ?? error
        defaultSection = try container.decodeIfPresent(DefaultSection.self, forKey: .defaultSection) ?? defaultSection
    }

    public override subscript(key: String) -> LocalizableSection? {
        switch key {
        case CodingKeys.error.stringValue: return error
        case CodingKeys.defaultSection.stringValue: return defaultSection
        default: return nil
        }
    }

    public final class Error: LocalizableSection {
        public var connectionError = ""
        public var authenticationError = ""
        public var unknownError = ""
        public var errorTitle = ""

        enum CodingKeys: String, CodingKey {
            case connectionError
            case authenticationError
            case unknownError
            case errorTitle
        }

        public override init() {
            super.init()
            connectionError = "\(classNameLowerCased()).connectionError"
            authenticationError = "\(classNameLowerCased()).authenticationError"
            unknownError = "\(classNameLowerCased()).unknownError"
            errorTitle = "\(classNameLowerCased()).errorTitle"
        }

        public required init(from decoder: Decoder) throws {
            super.init()
            let container = try decoder.container(keyedBy: CodingKeys.self)
            connectionError = try container.decodeIfPresent(String.self, forKey: .connectionError) ?? "__connectionError"
            authenticationError = try container.decodeIfPresent(String.self, forKey: .authenticationError) ?? "__authenticationError"
            unknownError = try container.decodeIfPresent(String.self, forKey: .unknownError) ?? "__unknownError"
            errorTitle = try container.decodeIfPresent(String.self, forKey: .errorTitle) ?? "__errorTitle"
        }

        public override subscript(key: String) -> String? {
            return ""
        }
    }

    public final class DefaultSection: LocalizableSection {
        public var cancel = ""
        public var skip = ""
        public var edit = ""
        public var back = ""
        public var ok = ""
        public var settings = ""
        public var previous = ""
        public var retry = ""
        public var save = ""
        public var later = ""
        public var yes = ""
        public var no = ""
        public var next = ""

        enum CodingKeys: String, CodingKey {
            case cancel
            case skip
            case edit
            case back
            case ok
            case settings
            case previous
            case retry
            case save
            case later
            case yes
            case no
            case next
        }

        public override init() {
            super.init()
            cancel = "\(classNameLowerCased()).cancel"
            skip = "\(classNameLowerCased()).skip"
            edit = "\(classNameLowerCased()).edit"
            back = "\(classNameLowerCased()).back"
            ok = "\(classNameLowerCased()).ok"
            settings = "\(classNameLowerCased()).settings"
            previous = "\(classNameLowerCased()).previous"
            retry = "\(classNameLowerCased()).retry"
            save = "\(classNameLowerCased()).save"
            later = "\(classNameLowerCased()).later"
            yes = "\(classNameLowerCased()).yes"
            no = "\(classNameLowerCased()).no"
            next = "\(classNameLowerCased()).next"
        }

        public required init(from decoder: Decoder) throws {
            super.init()
            let container = try decoder.container(keyedBy: CodingKeys.self)
            cancel = try container.decodeIfPresent(String.self, forKey: .cancel) ?? "__cancel"
            skip = try container.decodeIfPresent(String.self, forKey: .skip) ?? "__skip"
            edit = try container.decodeIfPresent(String.self, forKey: .edit) ?? "__edit"
            back = try container.decodeIfPresent(String.self, forKey: .back) ?? "__back"
            ok = try container.decodeIfPresent(String.self, forKey: .ok) ?? "__ok"
            settings = try container.decodeIfPresent(String.self, forKey: .settings) ?? "__settings"
            previous = try container.decodeIfPresent(String.self, forKey: .previous) ?? "__previous"
            retry = try container.decodeIfPresent(String.self, forKey: .retry) ?? "__retry"
            save = try container.decodeIfPresent(String.self, forKey: .save) ?? "__save"
            later = try container.decodeIfPresent(String.self, forKey: .later) ?? "__later"
            yes = try container.decodeIfPresent(String.self, forKey: .yes) ?? "__yes"
            no = try container.decodeIfPresent(String.self, forKey: .no) ?? "__no"
            next = try container.decodeIfPresent(String.self, forKey: .next) ?? "__next"
        }

        public override subscript(key: String) -> String? {
            return ""
        }
    }
}

